// node_modules/delegate-it/delegate.js
var ledger = /* @__PURE__ */ new WeakMap();
function editLedger(wanted, baseElement, callback, setup) {
  if (!wanted && !ledger.has(baseElement)) {
    return false;
  }
  const elementMap = ledger.get(baseElement) ?? /* @__PURE__ */ new WeakMap();
  ledger.set(baseElement, elementMap);
  const setups = elementMap.get(callback) ?? /* @__PURE__ */ new Set();
  elementMap.set(callback, setups);
  const existed = setups.has(setup);
  if (wanted) {
    setups.add(setup);
  } else {
    setups.delete(setup);
  }
  return existed && wanted;
}
function safeClosest(event, selector) {
  let target = event.target;
  if (target instanceof Text) {
    target = target.parentElement;
  }
  if (target instanceof Element && event.currentTarget instanceof Element) {
    const closest = target.closest(selector);
    if (closest && event.currentTarget.contains(closest)) {
      return closest;
    }
  }
}
function delegate(selector, type, callback, options = {}) {
  const { signal, base = document } = options;
  if (signal == null ? void 0 : signal.aborted) {
    return;
  }
  const { once, ...nativeListenerOptions } = options;
  const baseElement = base instanceof Document ? base.documentElement : base;
  const capture = Boolean(typeof options === "object" ? options.capture : options);
  const listenerFn = (event) => {
    const delegateTarget = safeClosest(event, selector);
    if (delegateTarget) {
      const delegateEvent = Object.assign(event, { delegateTarget });
      callback.call(baseElement, delegateEvent);
      if (once) {
        baseElement.removeEventListener(type, listenerFn, nativeListenerOptions);
        editLedger(false, baseElement, callback, setup);
      }
    }
  };
  const setup = JSON.stringify({ selector, type, capture });
  const isAlreadyListening = editLedger(true, baseElement, callback, setup);
  if (!isAlreadyListening) {
    baseElement.addEventListener(type, listenerFn, nativeListenerOptions);
  }
  signal == null ? void 0 : signal.addEventListener("abort", () => {
    editLedger(false, baseElement, callback, setup);
  });
}
var delegate_default = delegate;

// node_modules/path-to-regexp/dist.es2015/index.js
function lexer(str) {
  var tokens = [];
  var i2 = 0;
  while (i2 < str.length) {
    var char = str[i2];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i2++, value: str[i2++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i2, value: str[i2++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j = i2 + 1;
      while (j < str.length) {
        var code = str.charCodeAt(j);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i2));
      tokens.push({ type: "NAME", index: i2, value: name });
      i2 = j;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j = i2 + 1;
      if (str[j] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j));
      }
      while (j < str.length) {
        if (str[j] === "\\") {
          pattern += str[j++] + str[j++];
          continue;
        }
        if (str[j] === ")") {
          count--;
          if (count === 0) {
            j++;
            break;
          }
        } else if (str[j] === "(") {
          count++;
          if (str[j + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j));
          }
        }
        pattern += str[j++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i2));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i2));
      tokens.push({ type: "PATTERN", index: i2, value: pattern });
      i2 = j;
      continue;
    }
    tokens.push({ type: "CHAR", index: i2, value: str[i2++] });
  }
  tokens.push({ type: "END", index: i2, value: "" });
  return tokens;
}
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
  var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");
  var result = [];
  var key = 0;
  var i2 = 0;
  var path = "";
  var tryConsume = function(type) {
    if (i2 < tokens.length && tokens[i2].type === type)
      return tokens[i2++].value;
  };
  var mustConsume = function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i2], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  };
  var consumeText = function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  };
  while (i2 < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || defaultPattern,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function match(str, options) {
  var keys = [];
  var re = pathToRegexp(str, keys, options);
  return regexpToFunction(re, keys, options);
}
function regexpToFunction(re, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.decode, decode = _a === void 0 ? function(x2) {
    return x2;
  } : _a;
  return function(pathname) {
    var m2 = re.exec(pathname);
    if (!m2)
      return false;
    var path = m2[0], index = m2.index;
    var params = /* @__PURE__ */ Object.create(null);
    var _loop_1 = function(i3) {
      if (m2[i3] === void 0)
        return "continue";
      var key = keys[i3 - 1];
      if (key.modifier === "*" || key.modifier === "+") {
        params[key.name] = m2[i3].split(key.prefix + key.suffix).map(function(value) {
          return decode(value, key);
        });
      } else {
        params[key.name] = decode(m2[i3], key);
      }
    };
    for (var i2 = 1; i2 < m2.length; i2++) {
      _loop_1(i2);
    }
    return { path, index, params };
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys) {
  if (!keys)
    return path;
  var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
  var index = 0;
  var execResult = groupsRegex.exec(path.source);
  while (execResult) {
    keys.push({
      // Use parenthesized substring match if available, index otherwise
      name: execResult[1] || index++,
      prefix: "",
      suffix: "",
      modifier: "",
      pattern: ""
    });
    execResult = groupsRegex.exec(path.source);
  }
  return path;
}
function arrayToRegexp(paths, keys, options) {
  var parts = paths.map(function(path) {
    return pathToRegexp(path, keys, options).source;
  });
  return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options));
}
function stringToRegexp(path, keys, options) {
  return tokensToRegexp(parse(path, options), keys, options);
}
function tokensToRegexp(tokens, keys, options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x2) {
    return x2;
  } : _d, _e = options.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options.endsWith, endsWith = _f === void 0 ? "" : _f;
  var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
  var delimiterRe = "[".concat(escapeString(delimiter), "]");
  var route = start ? "^" : "";
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    if (typeof token === "string") {
      route += escapeString(encode(token));
    } else {
      var prefix = escapeString(encode(token.prefix));
      var suffix = escapeString(encode(token.suffix));
      if (token.pattern) {
        if (keys)
          keys.push(token);
        if (prefix || suffix) {
          if (token.modifier === "+" || token.modifier === "*") {
            var mod = token.modifier === "*" ? "?" : "";
            route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod);
          } else {
            route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier);
          }
        } else {
          if (token.modifier === "+" || token.modifier === "*") {
            route += "((?:".concat(token.pattern, ")").concat(token.modifier, ")");
          } else {
            route += "(".concat(token.pattern, ")").concat(token.modifier);
          }
        }
      } else {
        route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier);
      }
    }
  }
  if (end) {
    if (!strict)
      route += "".concat(delimiterRe, "?");
    route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
  } else {
    var endToken = tokens[tokens.length - 1];
    var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
    if (!strict) {
      route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
    }
    if (!isEndDelimited) {
      route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
    }
  }
  return new RegExp(route, flags(options));
}
function pathToRegexp(path, keys, options) {
  if (path instanceof RegExp)
    return regexpToRegexp(path, keys);
  if (Array.isArray(path))
    return arrayToRegexp(path, keys, options);
  return stringToRegexp(path, keys, options);
}

// node_modules/swup/dist/Swup.modern.js
function s() {
  return s = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var s2 = arguments[e];
      for (var i2 in s2)
        Object.prototype.hasOwnProperty.call(s2, i2) && (t[i2] = s2[i2]);
    }
    return t;
  }, s.apply(this, arguments);
}
var i = (t, e) => String(t).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e || "";
var n = ({ hash: t } = {}) => location.pathname + location.search + (t ? location.hash : "");
var o = (t, e = {}) => {
  const i2 = s({ url: t = t || n({ hash: true }), random: Math.random(), source: "swup" }, e);
  history.pushState(i2, "", t);
};
var r = (t = null, e = {}) => {
  t = t || n({ hash: true });
  const i2 = s({}, history.state, { url: t, random: Math.random(), source: "swup" }, e);
  history.replaceState(i2, "", t);
};
var a = (e, i2, n2, o2) => {
  const r2 = new AbortController();
  return o2 = s({}, o2, { signal: r2.signal }), delegate_default(e, i2, n2, o2), { destroy: () => r2.abort() };
};
var l = class _l extends URL {
  constructor(t, e = document.baseURI) {
    super(t.toString(), e);
  }
  get url() {
    return this.pathname + this.search;
  }
  static fromElement(t) {
    const e = t.getAttribute("href") || t.getAttribute("xlink:href") || "";
    return new _l(e);
  }
  static fromUrl(t) {
    return new _l(t);
  }
};
var h = (t, s2) => {
  try {
    return match(t, s2);
  } catch (e) {
    throw new Error(`[swup] Error parsing path "${t}":
${e}`);
  }
};
var c = class {
  constructor(t) {
    this.swup = void 0, this.pages = /* @__PURE__ */ new Map(), this.swup = t;
  }
  get size() {
    return this.pages.size;
  }
  get all() {
    const t = /* @__PURE__ */ new Map();
    return this.pages.forEach((e, i2) => {
      t.set(i2, s({}, e));
    }), t;
  }
  has(t) {
    return this.pages.has(this.resolve(t));
  }
  get(t) {
    const e = this.pages.get(this.resolve(t));
    return e ? s({}, e) : e;
  }
  set(t, e) {
    e = s({}, e, { url: t = this.resolve(t) }), this.pages.set(t, e), this.swup.hooks.callSync("cache:set", { page: e });
  }
  update(t, e) {
    t = this.resolve(t);
    const i2 = s({}, this.get(t), e, { url: t });
    this.pages.set(t, i2);
  }
  delete(t) {
    this.pages.delete(this.resolve(t));
  }
  clear() {
    this.pages.clear(), this.swup.hooks.callSync("cache:clear");
  }
  prune(t) {
    this.pages.forEach((e, s2) => {
      t(s2, e) && this.delete(s2);
    });
  }
  resolve(t) {
    const { url: e } = l.fromUrl(t);
    return this.swup.resolveUrl(e);
  }
};
var u = (t, e = document) => e.querySelector(t);
var p = (t, e = document) => Array.from(e.querySelectorAll(t));
var d = () => new Promise((t) => {
  requestAnimationFrame(() => {
    requestAnimationFrame(() => {
      t();
    });
  });
});
function m(t) {
  return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then;
}
function g(t, e = []) {
  return new Promise((s2, i2) => {
    const n2 = t(...e);
    m(n2) ? n2.then(s2, i2) : s2(n2);
  });
}
function f(t) {
  var e;
  return null == (e = t = t || document.body) ? void 0 : e.offsetHeight;
}
var w = (t) => window.CSS && window.CSS.escape ? CSS.escape(t) : t;
var v = (t) => 1e3 * Number(t.slice(0, -1).replace(",", "."));
var y = class {
  constructor(t) {
    this.swup = void 0, this.swupClasses = ["to-", "is-changing", "is-rendering", "is-popstate", "is-animating"], this.swup = t;
  }
  get selectors() {
    const { scope: t } = this.swup.visit.animation;
    return "containers" === t ? this.swup.visit.containers : "html" === t ? ["html"] : Array.isArray(t) ? t : [];
  }
  get selector() {
    return this.selectors.join(",");
  }
  get targets() {
    return this.selector.trim() ? p(this.selector) : [];
  }
  add(...t) {
    this.targets.forEach((e) => e.classList.add(...t));
  }
  remove(...t) {
    this.targets.forEach((e) => e.classList.remove(...t));
  }
  clear() {
    this.targets.forEach((t) => {
      const e = t.className.split(" ").filter((t2) => this.isSwupClass(t2));
      t.classList.remove(...e);
    });
  }
  isSwupClass(t) {
    return this.swupClasses.some((e) => t.startsWith(e));
  }
};
function k({ to: t, from: e = this.currentPageUrl, hash: s2, animate: i2 = true, animation: n2, el: o2, event: r2, action: a2 = "push", resetScroll: l2 = true }) {
  return { from: { url: e }, to: { url: t }, containers: this.options.containers, animation: { animate: i2, wait: false, name: n2, scope: this.options.animationScope, selector: this.options.animationSelector }, trigger: { el: o2, event: r2 }, history: { action: a2, popstate: false, direction: void 0 }, scroll: { reset: l2, target: s2 } };
}
var S = class {
  constructor(t) {
    this.swup = void 0, this.registry = /* @__PURE__ */ new Map(), this.hooks = ["animation:out:start", "animation:out:await", "animation:out:end", "animation:in:start", "animation:in:await", "animation:in:end", "animation:skip", "cache:clear", "cache:set", "content:replace", "content:scroll", "enable", "disable", "fetch:request", "fetch:error", "history:popstate", "link:click", "link:self", "link:anchor", "link:newtab", "page:load", "page:view", "scroll:top", "scroll:anchor", "visit:start", "visit:end"], this.swup = t, this.init();
  }
  init() {
    this.hooks.forEach((t) => this.create(t));
  }
  create(t) {
    this.registry.has(t) || this.registry.set(t, /* @__PURE__ */ new Map());
  }
  exists(t) {
    return this.registry.has(t);
  }
  get(t) {
    const e = this.registry.get(t);
    if (e)
      return e;
    console.error(`Unknown hook '${t}'`);
  }
  clear() {
    this.registry.forEach((t) => t.clear());
  }
  on(t, e, i2 = {}) {
    const n2 = this.get(t);
    if (!n2)
      return console.warn(`Hook '${t}' not found.`), () => {
      };
    const o2 = s({}, i2, { id: n2.size + 1, hook: t, handler: e });
    return n2.set(e, o2), () => this.off(t, e);
  }
  before(t, e, i2 = {}) {
    return this.on(t, e, s({}, i2, { before: true }));
  }
  replace(t, e, i2 = {}) {
    return this.on(t, e, s({}, i2, { replace: true }));
  }
  once(t, e, i2 = {}) {
    return this.on(t, e, s({}, i2, { once: true }));
  }
  off(t, e) {
    const s2 = this.get(t);
    s2 && e ? s2.delete(e) || console.warn(`Handler for hook '${t}' not found.`) : s2 && s2.clear();
  }
  async call(t, e, s2) {
    const { before: i2, handler: n2, after: o2 } = this.getHandlers(t, s2);
    await this.run(i2, e);
    const [r2] = await this.run(n2, e);
    return await this.run(o2, e), this.dispatchDomEvent(t, e), r2;
  }
  callSync(t, e, s2) {
    const { before: i2, handler: n2, after: o2 } = this.getHandlers(t, s2);
    this.runSync(i2, e);
    const [r2] = this.runSync(n2, e);
    return this.runSync(o2, e), this.dispatchDomEvent(t, e), r2;
  }
  async run(t, e) {
    const s2 = [];
    for (const { hook: i2, handler: n2, defaultHandler: o2, once: r2 } of t) {
      const t2 = await g(n2, [this.swup.visit, e, o2]);
      s2.push(t2), r2 && this.off(i2, n2);
    }
    return s2;
  }
  runSync(t, e) {
    const s2 = [];
    for (const { hook: i2, handler: n2, defaultHandler: o2, once: r2 } of t) {
      const t2 = n2(this.swup.visit, e, o2);
      s2.push(t2), m(t2) && console.warn(`Promise returned from handler for synchronous hook '${i2}'.Swup will not wait for it to resolve.`), r2 && this.off(i2, n2);
    }
    return s2;
  }
  getHandlers(t, e) {
    const s2 = this.get(t);
    if (!s2)
      return { found: false, before: [], handler: [], after: [], replaced: false };
    const i2 = this.sortRegistrations, n2 = Array.from(s2.values()), o2 = n2.filter(({ before: t2, replace: e2 }) => t2 && !e2).sort(i2), r2 = n2.filter(({ replace: t2 }) => t2).sort(i2), a2 = n2.filter(({ before: t2, replace: e2 }) => !t2 && !e2).sort(i2), l2 = r2.length > 0;
    let h2 = [];
    if (e && (h2 = [{ id: 0, hook: t, handler: e }], l2)) {
      const s3 = r2.length - 1, i3 = (t2) => {
        const s4 = r2[t2 - 1];
        return s4 ? (e2, n3) => s4.handler(e2, n3, i3(t2 - 1)) : e;
      };
      h2 = [{ id: 0, hook: t, handler: r2[s3].handler, defaultHandler: i3(s3) }];
    }
    return { found: true, before: o2, handler: h2, after: a2, replaced: l2 };
  }
  sortRegistrations(t, e) {
    var s2, i2;
    return (null != (s2 = t.priority) ? s2 : 0) - (null != (i2 = e.priority) ? i2 : 0) || t.id - e.id || 0;
  }
  dispatchDomEvent(t, e) {
    document.dispatchEvent(new CustomEvent(`swup:${t}`, { detail: { hook: t, args: e, visit: this.swup.visit } }));
  }
};
var b = (t) => {
  if (t && "#" === t.charAt(0) && (t = t.substring(1)), !t)
    return null;
  const e = decodeURIComponent(t);
  let s2 = document.getElementById(t) || document.getElementById(e) || u(`a[name='${w(t)}']`) || u(`a[name='${w(e)}']`);
  return s2 || "top" !== t || (s2 = document.body), s2;
};
var U = "transition";
var P = "animation";
async function E({ elements: t, selector: e }) {
  if (false === e && !t)
    return;
  let s2 = [];
  if (t)
    s2 = Array.from(t);
  else if (e && (s2 = p(e, document.body), !s2.length))
    return void console.warn(`[swup] No elements found matching animationSelector \`${e}\``);
  const i2 = s2.map((t2) => function(t3) {
    const { type: e2, timeout: s3, propCount: i3 } = function(t4, e3) {
      const s4 = window.getComputedStyle(t4), i4 = C(s4, `${U}Delay`), n2 = C(s4, `${U}Duration`), o2 = $(i4, n2), r2 = C(s4, `${P}Delay`), a2 = C(s4, `${P}Duration`), l2 = $(r2, a2);
      let h2 = null, c2 = 0, u2 = 0;
      return c2 = Math.max(o2, l2), h2 = c2 > 0 ? o2 > l2 ? U : P : null, u2 = h2 ? h2 === U ? n2.length : a2.length : 0, { type: h2, timeout: c2, propCount: u2 };
    }(t3);
    return !(!e2 || !s3) && new Promise((n2) => {
      const o2 = `${e2}end`, r2 = performance.now();
      let a2 = 0;
      const l2 = () => {
        t3.removeEventListener(o2, h2), n2();
      }, h2 = (e3) => {
        if (e3.target === t3) {
          if (!function(t4) {
            return [`${U}end`, `${P}end`].includes(t4.type);
          }(e3))
            throw new Error("Not a transition or animation event.");
          (performance.now() - r2) / 1e3 < e3.elapsedTime || ++a2 >= i3 && l2();
        }
      };
      setTimeout(() => {
        a2 < i3 && l2();
      }, s3 + 1), t3.addEventListener(o2, h2);
    });
  }(t2));
  i2.filter(Boolean).length > 0 ? await Promise.all(i2) : e && console.warn(`[swup] No CSS animation duration defined on elements matching \`${e}\``);
}
function C(t, e) {
  return (t[e] || "").split(", ");
}
function $(t, e) {
  for (; t.length < e.length; )
    t = t.concat(t);
  return Math.max(...e.map((e2, s2) => v(e2) + v(t[s2])));
}
function x(t, e = {}, i2 = {}) {
  if (this.shouldIgnoreVisit(t, { el: i2.el, event: i2.event }))
    return void (window.location.href = t);
  const { url: n2, hash: o2 } = l.fromUrl(t);
  this.visit = this.createVisit(s({}, i2, { to: n2, hash: o2 })), this.performNavigation(n2, e);
}
async function A(t, e = {}) {
  if ("string" != typeof t)
    throw new Error("swup.navigate() requires a URL parameter");
  const { el: s2 } = this.visit.trigger;
  this.visit.to.url = l.fromUrl(t).url, e.referrer = e.referrer || this.currentPageUrl, false === e.animate && (this.visit.animation.animate = false), this.visit.animation.animate || this.classes.clear();
  const i2 = e.history || (null == s2 ? void 0 : s2.getAttribute("data-swup-history")) || void 0;
  i2 && ["push", "replace"].includes(i2) && (this.visit.history.action = i2);
  const a2 = e.animation || (null == s2 ? void 0 : s2.getAttribute("data-swup-animation")) || void 0;
  a2 && (this.visit.animation.name = a2);
  try {
    await this.hooks.call("visit:start");
    const s3 = this.hooks.call("page:load", { options: e }, async (t2, e2) => {
      const s4 = this.cache.get(t2.to.url);
      return e2.page = s4 || await this.fetchPage(t2.to.url, e2.options), e2.cache = !!s4, e2.page;
    });
    if (!this.visit.history.popstate) {
      const e2 = t + (this.visit.scroll.target || "");
      "replace" === this.visit.history.action ? r(e2) : o(e2, { index: this.currentHistoryIndex + 1 });
    }
    if (this.currentPageUrl = n(), this.visit.animation.wait) {
      const { html: t2 } = await s3;
      this.visit.to.html = t2;
    }
    const i3 = this.animatePageOut(), [a3] = await Promise.all([s3, i3]);
    await this.renderPage(this.visit.to.url, a3), await this.animatePageIn(), await this.hooks.call("visit:end", void 0, () => this.classes.clear());
  } catch (t2) {
    if (!t2)
      return;
    console.error(t2), this.options.skipPopStateHandling = () => (window.location.href = this.visit.to.url, true), window.history.go(-1);
  }
}
var H = class extends Error {
  constructor(t, e) {
    super(t), this.url = void 0, this.status = void 0, this.name = "FetchError", this.url = e.url, this.status = e.status;
  }
};
async function q(t, e = {}) {
  t = l.fromUrl(t).url;
  const i2 = s({}, this.options.requestHeaders, e.headers);
  e = s({}, e, { headers: i2 });
  const n2 = await this.hooks.call("fetch:request", { url: t, options: e }, (t2, { url: e2, options: s2 }) => fetch(e2, s2)), { status: o2, url: r2 } = n2, a2 = await n2.text();
  if (500 === o2)
    throw this.hooks.call("fetch:error", { status: o2, response: n2, url: r2 }), new H(`Server error: ${r2}`, { status: o2, url: r2 });
  if (!a2)
    throw new H(`Empty response: ${r2}`, { status: o2, url: r2 });
  const { url: h2 } = l.fromUrl(r2), c2 = { url: h2, html: a2 };
  return t === h2 && this.cache.set(c2.url, c2), c2;
}
var L = async function() {
  this.visit.animation.animate ? (await this.hooks.call("animation:out:start", void 0, (t) => {
    this.classes.add("is-changing", "is-leaving", "is-animating"), t.history.popstate && this.classes.add("is-popstate"), t.animation.name && this.classes.add(`to-${i(t.animation.name)}`);
  }), await this.hooks.call("animation:out:await", { skip: false }, async (t, { skip: e }) => {
    e || await this.awaitAnimations({ selector: t.animation.selector });
  }), await this.hooks.call("animation:out:end")) : await this.hooks.call("animation:skip");
};
var R = function({ html: t }, { containers: e } = this.options) {
  var s2;
  const i2 = new DOMParser().parseFromString(t, "text/html"), n2 = (null == (s2 = i2.querySelector("title")) ? void 0 : s2.innerText) || "";
  return document.title = n2, e.map((t2) => {
    const e2 = document.querySelector(t2), s3 = i2.querySelector(t2);
    return e2 && s3 ? (e2.replaceWith(s3), true) : (e2 || console.warn(`[swup] Container missing in current document: ${t2}`), s3 || console.warn(`[swup] Container missing in incoming document: ${t2}`), false);
  }).filter(Boolean).length === e.length;
};
var I = function() {
  const t = { behavior: "auto" }, { target: e, reset: i2 } = this.visit.scroll;
  let n2 = false;
  return e && (n2 = this.hooks.callSync("scroll:anchor", { hash: e, options: t }, (t2, { hash: e2, options: s2 }) => {
    const i3 = this.getAnchorElement(e2 || "");
    return i3 && i3.scrollIntoView(s2), !!i3;
  })), i2 && !n2 && (n2 = this.hooks.callSync("scroll:top", { options: t }, (t2, { options: e2 }) => (window.scrollTo(s({ top: 0, left: 0 }, e2)), true))), n2;
};
var N = async function() {
  if (!this.visit.animation.animate)
    return;
  const t = this.hooks.call("animation:in:await", { skip: false }, async (t2, { skip: e }) => {
    e || await this.awaitAnimations({ selector: t2.animation.selector });
  });
  await d(), await this.hooks.call("animation:in:start", void 0, () => {
    this.classes.remove("is-animating");
  }), await t, await this.hooks.call("animation:in:end");
};
var D = async function(t, e) {
  const { url: s2, html: o2 } = e;
  this.classes.remove("is-leaving"), this.isSameResolvedUrl(n(), t) && (this.isSameResolvedUrl(n(), s2) || (r(s2), this.currentPageUrl = n(), this.visit.to.url = this.currentPageUrl), this.visit.animation.animate && this.classes.add("is-rendering"), this.visit.to.html = o2, await this.hooks.call("content:replace", { page: e }, (t2, { page: e2 }) => {
    if (!this.replaceContent(e2, { containers: t2.containers }))
      throw new Error("[swup] Container mismatch, aborting");
    t2.animation.animate && (this.classes.add("is-animating", "is-changing", "is-rendering"), t2.animation.name && this.classes.add(`to-${i(t2.animation.name)}`));
  }), await this.hooks.call("content:scroll", void 0, () => this.scrollToContent()), await this.hooks.call("page:view", { url: this.currentPageUrl, title: document.title }), this.options.cache || this.cache.clear());
};
var V = function(t) {
  var e;
  if (null == (e = t) ? void 0 : e.isSwupPlugin) {
    if (t.swup = this, !t._checkRequirements || t._checkRequirements())
      return t._beforeMount && t._beforeMount(), t.mount(), this.plugins.push(t), this.plugins;
  } else
    console.error("Not a swup plugin instance", t);
};
function M(t) {
  const e = this.findPlugin(t);
  if (e)
    return e.unmount(), e._afterUnmount && e._afterUnmount(), this.plugins = this.plugins.filter((t2) => t2 !== e), this.plugins;
  console.error("No such plugin", e);
}
function O(t) {
  return this.plugins.find((e) => e === t || e.name === t || e.name === `Swup${t}`);
}
function T(t) {
  if ("function" != typeof this.options.resolveUrl)
    return console.warn("[swup] options.resolveUrl expects a callback function."), t;
  const e = this.options.resolveUrl(t);
  return e && "string" == typeof e ? e.startsWith("//") || e.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t) : e : (console.warn("[swup] options.resolveUrl needs to return a url"), t);
}
function W(t, e) {
  return this.resolveUrl(t) === this.resolveUrl(e);
}
var _ = { animateHistoryBrowsing: false, animationSelector: '[class*="transition-"]', animationScope: "html", cache: true, containers: ["#swup"], ignoreVisit: (t, { el: e } = {}) => !(null == e || !e.closest("[data-no-swup]")), linkSelector: "a[href]", plugins: [], resolveUrl: (t) => t, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: (t) => {
  var e;
  return "swup" !== (null == (e = t.state) ? void 0 : e.source);
} };
var B = class {
  constructor(t = {}) {
    this.version = "4.1.0", this.options = void 0, this.defaults = _, this.plugins = [], this.visit = void 0, this.cache = void 0, this.hooks = void 0, this.classes = void 0, this.currentPageUrl = n(), this.currentHistoryIndex = 1, this.clickDelegate = void 0, this.use = V, this.unuse = M, this.findPlugin = O, this.log = () => {
    }, this.navigate = x, this.performNavigation = A, this.createVisit = k, this.delegateEvent = a, this.fetchPage = q, this.awaitAnimations = E, this.renderPage = D, this.replaceContent = R, this.animatePageIn = N, this.animatePageOut = L, this.scrollToContent = I, this.getAnchorElement = b, this.getCurrentUrl = n, this.resolveUrl = T, this.isSameResolvedUrl = W, this.options = s({}, this.defaults, t), this.handleLinkClick = this.handleLinkClick.bind(this), this.handlePopState = this.handlePopState.bind(this), this.cache = new c(this), this.classes = new y(this), this.hooks = new S(this), this.visit = this.createVisit({ to: void 0 }), this.checkRequirements() && this.enable();
  }
  checkRequirements() {
    return "undefined" != typeof Promise || (console.warn("Promise is not supported"), false);
  }
  async enable() {
    const { linkSelector: t } = this.options;
    this.clickDelegate = this.delegateEvent(t, "click", this.handleLinkClick), window.addEventListener("popstate", this.handlePopState), this.options.plugins.forEach((t2) => this.use(t2)), r(null, { index: 1 }), await d(), await this.hooks.call("enable", void 0, () => {
      document.documentElement.classList.add("swup-enabled");
    });
  }
  async destroy() {
    this.clickDelegate.destroy(), window.removeEventListener("popstate", this.handlePopState), this.cache.clear(), this.options.plugins.forEach((t) => this.unuse(t)), await this.hooks.call("disable", void 0, () => {
      document.documentElement.classList.remove("swup-enabled");
    }), this.hooks.clear();
  }
  shouldIgnoreVisit(t, { el: e, event: s2 } = {}) {
    const { origin: i2, url: n2, hash: o2 } = l.fromUrl(t);
    return i2 !== window.location.origin || !(!e || !this.triggerWillOpenNewWindow(e)) || !!this.options.ignoreVisit(n2 + o2, { el: e, event: s2 });
  }
  handleLinkClick(t) {
    const e = t.delegateTarget, { href: s2, url: i2, hash: n2 } = l.fromElement(e);
    this.shouldIgnoreVisit(s2, { el: e, event: t }) || (this.visit = this.createVisit({ to: i2, hash: n2, el: e, event: t }), t.metaKey || t.ctrlKey || t.shiftKey || t.altKey ? this.hooks.call("link:newtab", { href: s2 }) : 0 === t.button && this.hooks.callSync("link:click", { el: e, event: t }, () => {
      var e2;
      const s3 = null != (e2 = this.visit.from.url) ? e2 : "";
      t.preventDefault(), i2 && i2 !== s3 ? this.isSameResolvedUrl(i2, s3) || this.performNavigation(i2) : n2 ? this.hooks.callSync("link:anchor", { hash: n2 }, () => {
        r(i2 + n2), this.scrollToContent();
      }) : this.hooks.callSync("link:self", void 0, () => {
        this.scrollToContent();
      });
    }));
  }
  handlePopState(t) {
    var e, s2, i2;
    const o2 = null != (e = null == (s2 = t.state) ? void 0 : s2.url) ? e : location.href;
    if (this.options.skipPopStateHandling(t))
      return;
    if (this.isSameResolvedUrl(n(), this.currentPageUrl))
      return;
    if (this.shouldIgnoreVisit(o2, { event: t }))
      return;
    const { url: r2, hash: a2 } = l.fromUrl(o2);
    this.visit = this.createVisit({ to: r2, hash: a2, event: t, animate: this.options.animateHistoryBrowsing, resetScroll: this.options.animateHistoryBrowsing }), this.visit.history.popstate = true;
    const h2 = Number(null == (i2 = t.state) ? void 0 : i2.index);
    h2 && (this.visit.history.direction = h2 - this.currentHistoryIndex > 0 ? "forwards" : "backwards"), this.hooks.callSync("history:popstate", { event: t }, () => {
      this.performNavigation(r2);
    });
  }
  triggerWillOpenNewWindow(t) {
    return !!t.matches('[download], [target="_blank"]');
  }
};

export {
  i,
  n,
  o,
  r,
  a,
  l,
  h,
  u,
  p,
  d,
  m,
  g,
  f,
  w,
  v,
  B
};
//# sourceMappingURL=chunk-DFMJAHVM.js.map
