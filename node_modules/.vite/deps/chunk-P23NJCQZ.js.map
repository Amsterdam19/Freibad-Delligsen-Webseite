{
  "version": 3,
  "sources": ["../../scrl/src/index.js", "../../@swup/scroll-plugin/src/index.js"],
  "sourcesContent": ["export default class Scrl {\n    _raf = null;\n    _positionY = 0;\n    _velocityY = 0;\n    _targetPositionY = 0;\n    _targetPositionYWithOffset = 0;\n    _direction = 0;\n\n    constructor(options) {\n        // default options\n        const defaults = {\n            onAlreadyAtPositions: () => {},\n            onCancel: () => {},\n            onEnd: () => {},\n            onStart: () => {},\n            onTick: () => {},\n            friction: .7, // 1 - .3\n            acceleration: .04,\n        }\n\n        // merge options\n        this.options = {\n            ...defaults,\n            ...options,\n        };\n\n        // set reverse friction\n        if (options && options.friction) {\n            this.options.friction = 1 - options.friction;\n        }\n\n        // register listener for cancel on wheel event\n        window.addEventListener('mousewheel', event => {\n            if (this._raf) {\n                this.options.onCancel();\n                cancelAnimationFrame(this._raf);\n                this._raf = null;\n            }\n        }, {\n            passive: true\n        });\n    }\n\n    scrollTo = (offset) => {\n        if (offset && offset.nodeType) {\n            // the offset is element\n            this._targetPositionY = Math.round(offset.getBoundingClientRect().top + window.pageYOffset);\n        } else if (parseInt(this._targetPositionY) === this._targetPositionY) {\n            // the offset is a number\n            this._targetPositionY = Math.round(offset);\n        } else {\n            console.error('Argument must be a number or an element.');\n            return;\n        }\n\n        // don't animate beyond the document height\n        if (this._targetPositionY > document.documentElement.scrollHeight - window.innerHeight) {\n            this._targetPositionY = document.documentElement.scrollHeight - window.innerHeight;\n        }\n\n        // calculated required values\n        this._positionY = document.body.scrollTop || document.documentElement.scrollTop;\n        this._direction = (this._positionY > this._targetPositionY) ? -1 : 1;\n        this._targetPositionYWithOffset = this._targetPositionY + this._direction;\n        this._velocityY = 0;\n\n        if (this._positionY !== this._targetPositionY) {\n            // start animation\n            this.options.onStart();\n            this._animate();\n        } else {\n            // page is already at the position\n            this.options.onAlreadyAtPositions();\n        }\n    };\n\n    _animate = () => {\n        const distance = this._update();\n        this._render();\n\n        if (this._direction === 1 && this._targetPositionY > this._positionY || this._direction === -1 && this._targetPositionY < this._positionY) {\n            // calculate next position\n            this._raf = requestAnimationFrame(this._animate);\n            this.options.onTick();\n        } else {\n            // finish and set position to the final position\n            this._positionY = this._targetPositionY;\n            this._render();\n            this._raf = null;\n            this.options.onTick();\n            this.options.onEnd();\n            // this.triggerEvent('scrollDone')\n        }\n    };\n\n    _update = () => {\n        const distance = this._targetPositionYWithOffset - this._positionY;\n        const attraction = distance * this.options.acceleration;\n\n        this._velocityY += attraction;\n\n        this._velocityY *= this.options.friction;\n        this._positionY += this._velocityY;\n\n        return Math.abs(distance);\n    };\n\n    _render = () => {\n        window.scrollTo(0, this._positionY);\n    };\n}\n", "import Plugin from '@swup/plugin';\nimport { getCurrentUrl, queryAll } from 'swup';\nimport Scrl from 'scrl';\n\n/**\n * Scroll Plugin\n * @extends Plugin\n */\nexport default class SwupScrollPlugin extends Plugin {\n\tname = 'SwupScrollPlugin';\n\n\trequires = { swup: '>=4' };\n\n\tdefaults = {\n\t\tdoScrollingRightAway: false,\n\t\tanimateScroll: {\n\t\t\tbetweenPages: true,\n\t\t\tsamePageWithHash: true,\n\t\t\tsamePage: true\n\t\t},\n\t\tscrollFriction: 0.3,\n\t\tscrollAcceleration: 0.04,\n\t\tgetAnchorElement: null,\n\t\toffset: 0,\n\t\tscrollContainers: `[data-swup-scroll-container]`,\n\t\tshouldResetScrollPosition: (link) => true\n\t};\n\n\tconstructor(options = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\tmount() {\n\t\tconst swup = this.swup;\n\n\t\tswup.hooks.create('scroll:start');\n\t\tswup.hooks.create('scroll:end');\n\n\t\t// Initialize Scrl lib for smooth animations\n\t\tthis.scrl = new Scrl({\n\t\t\tonStart: () => swup.hooks.callSync('scroll:start'),\n\t\t\tonEnd: () => swup.hooks.callSync('scroll:end'),\n\t\t\tonCancel: () => swup.hooks.callSync('scroll:end'),\n\t\t\tfriction: this.options.scrollFriction,\n\t\t\tacceleration: this.options.scrollAcceleration\n\t\t});\n\n\t\t// Add scrollTo method to swup and animate based on current animateScroll option\n\t\tswup.scrollTo = (offset, animate = true) => {\n\t\t\tif (animate) {\n\t\t\t\tthis.scrl.scrollTo(offset);\n\t\t\t} else {\n\t\t\t\tswup.hooks.callSync('scroll:start');\n\t\t\t\twindow.scrollTo(0, offset);\n\t\t\t\tswup.hooks.callSync('scroll:end');\n\t\t\t}\n\t\t};\n\n\t\t// This object will hold all scroll positions\n\t\tthis.scrollPositionsStore = {};\n\t\t// this URL helps with storing the current scroll positions on `willReplaceContent`\n\t\tthis.currentCacheKey = this.getCurrentCacheKey();\n\n\t\t// disable browser scroll control on popstates when\n\t\t// animateHistoryBrowsing option is enabled in swup.\n\t\t// Cache the previous setting to be able to properly restore it on unmount\n\t\tthis.previousScrollRestoration = window.history.scrollRestoration;\n\t\tif (swup.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t// reset scroll positions when a visit starts\n\t\tthis.on('visit:start', this.maybeResetScrollPositions);\n\n\t\t// scroll to the top of the page when a visit starts, before replacing the content\n\t\tthis.on('visit:start', this.onVisitStart);\n\n\t\t// store the current scroll positions before replacing the content\n\t\tthis.before('content:replace', this.onBeforeReplaceContent);\n\n\t\t// scroll to the top or target element after replacing the content\n\t\tthis.replace('content:scroll', this.onScrollToContent);\n\n\t\t// scroll to the top of the page\n\t\tthis.replace('scroll:top', this.handleScrollToTop);\n\n\t\t// scroll to an anchor on the same page\n\t\tthis.replace('scroll:anchor', this.handleScrollToAnchor);\n\t}\n\n\t/**\n\t * Runs when the plugin is unmounted\n\t */\n\tunmount() {\n\t\tsuper.unmount();\n\n\t\twindow.history.scrollRestoration = this.previousScrollRestoration;\n\t\tdelete this.swup.scrollTo;\n\t\tdelete this.scrl;\n\t}\n\n\t/**\n\t * Detects if a scroll should be animated, based on context\n\t * @param {string} context\n\t * @returns {boolean}\n\t */\n\tshouldAnimate(context) {\n\t\tif (typeof this.options.animateScroll === 'boolean') {\n\t\t\treturn this.options.animateScroll;\n\t\t}\n\t\treturn this.options.animateScroll[context];\n\t}\n\n\t/**\n\t * Get an element based on anchor\n\t * @param {string} hash\n\t * @returns {mixed}\n\t */\n\tgetAnchorElement = (hash = '') => {\n\t\t// Look for a custom function provided via the plugin options\n\t\tif (typeof this.options.getAnchorElement === 'function') {\n\t\t\treturn this.options.getAnchorElement(hash);\n\t\t} else {\n\t\t\treturn this.swup.getAnchorElement(hash);\n\t\t}\n\t};\n\n\t/**\n\t * Get the offset for a scroll\n\t * @param {(HtmlELement|null)} element\n\t * @returns {number}\n\t */\n\tgetOffset = (element = null) => {\n\t\t// If options.offset is a function, apply and return it\n\t\tif (typeof this.options.offset === 'function') {\n\t\t\treturn parseInt(this.options.offset(element), 10);\n\t\t}\n\t\t// Otherwise, return the sanitized offset\n\t\treturn parseInt(this.options.offset, 10);\n\t};\n\n\t/**\n\t * Scroll to top on `scroll:top` hook\n\t */\n\thandleScrollToTop = () => {\n\t\tthis.swup.scrollTo(0, this.shouldAnimate('samePage'));\n\t\treturn true;\n\t};\n\n\t/**\n\t * Scroll to anchor on `scroll:anchor` hook\n\t */\n\thandleScrollToAnchor = (visit, { hash }) => {\n\t\treturn this.maybeScrollToAnchor(hash, this.shouldAnimate('samePageWithHash'));\n\t};\n\n\t/**\n\t * Attempts to scroll to an anchor\n\t * @param {string} hash\n\t * @param {boolean} animate\n\t * @returns {boolean}\n\t */\n\tmaybeScrollToAnchor(hash, animate = false) {\n\t\tif (!hash) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst element = this.getAnchorElement(hash);\n\t\tif (!element) {\n\t\t\tconsole.warn(`Anchor target ${hash} not found`);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(element instanceof Element)) {\n\t\t\tconsole.warn(`Anchor target ${hash} is not a DOM node`);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { top: elementTop } = element.getBoundingClientRect();\n\t\tconst top = elementTop + window.scrollY - this.getOffset(element);\n\t\tthis.swup.scrollTo(top, animate);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check whether to scroll in `visit:start` hook\n\t */\n\tonVisitStart = (visit) => {\n\t\tif (this.options.doScrollingRightAway && !visit.scroll.target) {\n\t\t\tvisit.scroll.scrolledToContent = true;\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t};\n\n\t/**\n\t * Check whether to scroll in `content:scroll` hook\n\t */\n\tonScrollToContent = (visit) => {\n\t\tif (!visit.scroll.scrolledToContent) {\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t\tthis.restoreScrollContainers(visit);\n\t};\n\n\t/**\n\t * Scrolls the window\n\t * @returns {void}\n\t */\n\tdoScrollingBetweenPages = (visit) => {\n\t\t// Bail early on popstate if not animated: browser will handle it\n\t\tif (visit.history.popstate && !visit.animation.animate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Try scrolling to a given anchor\n\t\tif (this.maybeScrollToAnchor(visit.scroll.target, this.shouldAnimate('betweenPages'))) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Allow not resetting scroll position\n\t\tif (!visit.scroll.reset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Finally, scroll to either the stored scroll position or to the very top of the page\n\t\tconst scrollPositions = this.getStoredScrollPositions(this.getCurrentCacheKey()) || {};\n\t\tconst top = scrollPositions.window?.top || 0;\n\n\t\t// Give possible JavaScript time to execute before scrolling\n\t\trequestAnimationFrame(() => this.swup.scrollTo(top, this.shouldAnimate('betweenPages')));\n\t};\n\n\t/**\n\t * Stores the current scroll positions for the URL we just came from\n\t */\n\tonBeforeReplaceContent = () => {\n\t\tthis.storeScrollPositions(this.currentCacheKey);\n\t\tthis.currentCacheKey = this.getCurrentCacheKey();\n\t};\n\n\t/**\n\t * Deletes the scroll positions for the URL a link is pointing to,\n\t * if shouldResetScrollPosition evaluates to true\n\t * @returns {void}\n\t */\n\tmaybeResetScrollPositions(visit) {\n\t\tconst { url } = visit.to;\n\t\tconst { el } = visit.trigger;\n\t\tconst shouldReset = !el || this.options.shouldResetScrollPosition(el);\n\t\tif (shouldReset) {\n\t\t\tthis.resetScrollPositions(url);\n\t\t}\n\t}\n\n\t/**\n\t * Stores the scroll positions for the current URL\n\t * @param {string} url\n\t * @returns {void}\n\t */\n\tstoreScrollPositions(url) {\n\t\t// retrieve the current scroll position for all containers\n\t\tconst containers = queryAll(this.options.scrollContainers).map((el) => ({\n\t\t\ttop: el.scrollTop,\n\t\t\tleft: el.scrollLeft\n\t\t}));\n\n\t\t// construct the final object entry, with the window scroll positions added\n\t\tthis.scrollPositionsStore[url] = {\n\t\t\twindow: { top: window.scrollY, left: window.scrollX },\n\t\t\tcontainers\n\t\t};\n\t}\n\n\t/**\n\t * Resets stored scroll positions for a given URL\n\t * @param {string} url\n\t */\n\tresetScrollPositions(url) {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\tdelete this.scrollPositionsStore[cacheKey];\n\t\tthis.scrollPositionsStore[cacheKey] = null;\n\t}\n\n\t/**\n\t * Get the stored scroll positions for a given URL from the cache\n\t * @returns {(object|undefined)}\n\t */\n\tgetStoredScrollPositions(url) {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\treturn this.scrollPositionsStore[cacheKey];\n\t}\n\n\t/**\n\t * Restore the scroll positions for all matching scrollContainers\n\t * @returns void\n\t */\n\trestoreScrollContainers() {\n\t\t// get the stored scroll positions from the cache\n\t\tconst scrollPositions = this.getStoredScrollPositions(this.getCurrentCacheKey()) || {};\n\t\tif (scrollPositions.containers == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// cycle through all containers on the current page and restore their scroll positions, if appropriate\n\t\tqueryAll(this.options.scrollContainers).forEach((el, index) => {\n\t\t\tconst scrollPosition = scrollPositions.containers[index];\n\t\t\tif (scrollPosition == null) return;\n\t\t\tel.scrollTop = scrollPosition.top;\n\t\t\tel.scrollLeft = scrollPosition.left;\n\t\t});\n\t}\n\n\t/**\n\t * Get the current cache key for the scroll positions.\n\t * @returns {string}\n\t */\n\tgetCurrentCacheKey() {\n\t\treturn this.swup.resolveUrl(getCurrentUrl());\n\t}\n}\n"],
  "mappings": "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",
  "names": ["Scrl", "constructor", "options", "this", "_raf", "_positionY", "_velocityY", "_targetPositionY", "_targetPositionYWithOffset", "_direction", "scrollTo", "offset", "nodeType", "Math", "round", "getBoundingClientRect", "top", "window", "pageYOffset", "parseInt", "console", "error", "document", "documentElement", "scrollHeight", "innerHeight", "body", "scrollTop", "onStart", "_animate", "onAlreadyAtPositions", "_update", "_render", "requestAnimationFrame", "onTick", "onEnd", "distance", "acceleration", "friction", "abs", "_extends", "onCancel", "addEventListener", "event", "cancelAnimationFrame", "passive", "SwupScrollPlugin", "Plugin", "constructor", "options", "super", "this", "name", "requires", "swup", "defaults", "doScrollingRightAway", "animateScroll", "betweenPages", "samePageWithHash", "samePage", "scrollFriction", "scrollAcceleration", "getAnchorElement", "offset", "scrollContainers", "shouldResetScrollPosition", "link", "hash", "getOffset", "element", "parseInt", "handleScrollToTop", "scrollTo", "shouldAnimate", "handleScrollToAnchor", "visit", "maybeScrollToAnchor", "onVisitStart", "scroll", "target", "scrolledToContent", "doScrollingBetweenPages", "onScrollToContent", "restoreScrollContainers", "_scrollPositions$wind", "history", "popstate", "animation", "animate", "reset", "top", "scrollPositions", "getStoredScrollPositions", "getCurrentCacheKey", "window", "requestAnimationFrame", "onBeforeReplaceContent", "storeScrollPositions", "currentCacheKey", "_extends", "mount", "hooks", "create", "scrl", "Scrl", "onStart", "callSync", "onEnd", "onCancel", "friction", "acceleration", "scrollPositionsStore", "previousScrollRestoration", "scrollRestoration", "animateHistoryBrowsing", "on", "maybeResetScrollPositions", "before", "replace", "unmount", "context", "console", "warn", "Element", "elementTop", "getBoundingClientRect", "scrollY", "url", "to", "el", "trigger", "resetScrollPositions", "containers", "queryAll", "map", "scrollTop", "left", "scrollLeft", "scrollX", "cacheKey", "resolveUrl", "forEach", "index", "e", "scrollPosition", "getCurrentUrl"]
}
