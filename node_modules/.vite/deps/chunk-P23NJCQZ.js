import {
  e
} from "./chunk-AMQVUKHH.js";
import {
  n,
  p
} from "./chunk-DFMJAHVM.js";

// node_modules/scrl/dist/index.modern.js
function t() {
  return t = Object.assign ? Object.assign.bind() : function(t2) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var o = arguments[i2];
      for (var s in o)
        Object.prototype.hasOwnProperty.call(o, s) && (t2[s] = o[s]);
    }
    return t2;
  }, t.apply(this, arguments);
}
var i = class {
  constructor(i2) {
    this._raf = null, this._positionY = 0, this._velocityY = 0, this._targetPositionY = 0, this._targetPositionYWithOffset = 0, this._direction = 0, this.scrollTo = (t2) => {
      if (t2 && t2.nodeType)
        this._targetPositionY = Math.round(t2.getBoundingClientRect().top + window.pageYOffset);
      else {
        if (parseInt(this._targetPositionY) !== this._targetPositionY)
          return void console.error("Argument must be a number or an element.");
        this._targetPositionY = Math.round(t2);
      }
      this._targetPositionY > document.documentElement.scrollHeight - window.innerHeight && (this._targetPositionY = document.documentElement.scrollHeight - window.innerHeight), this._positionY = document.body.scrollTop || document.documentElement.scrollTop, this._direction = this._positionY > this._targetPositionY ? -1 : 1, this._targetPositionYWithOffset = this._targetPositionY + this._direction, this._velocityY = 0, this._positionY !== this._targetPositionY ? (this.options.onStart(), this._animate()) : this.options.onAlreadyAtPositions();
    }, this._animate = () => {
      this._update(), this._render(), 1 === this._direction && this._targetPositionY > this._positionY || -1 === this._direction && this._targetPositionY < this._positionY ? (this._raf = requestAnimationFrame(this._animate), this.options.onTick()) : (this._positionY = this._targetPositionY, this._render(), this._raf = null, this.options.onTick(), this.options.onEnd());
    }, this._update = () => {
      const t2 = this._targetPositionYWithOffset - this._positionY;
      return this._velocityY += t2 * this.options.acceleration, this._velocityY *= this.options.friction, this._positionY += this._velocityY, Math.abs(t2);
    }, this._render = () => {
      window.scrollTo(0, this._positionY);
    }, this.options = t({}, { onAlreadyAtPositions: () => {
    }, onCancel: () => {
    }, onEnd: () => {
    }, onStart: () => {
    }, onTick: () => {
    }, friction: 0.7, acceleration: 0.04 }, i2), i2 && i2.friction && (this.options.friction = 1 - i2.friction), window.addEventListener("mousewheel", (t2) => {
      this._raf && (this.options.onCancel(), cancelAnimationFrame(this._raf), this._raf = null);
    }, { passive: true });
  }
};

// node_modules/@swup/scroll-plugin/dist/index.modern.js
function l() {
  return l = Object.assign ? Object.assign.bind() : function(o) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var s = arguments[t2];
      for (var e2 in s)
        Object.prototype.hasOwnProperty.call(s, e2) && (o[e2] = s[e2]);
    }
    return o;
  }, l.apply(this, arguments);
}
var r = class extends e {
  constructor(o = {}) {
    super(), this.name = "SwupScrollPlugin", this.requires = { swup: ">=4" }, this.defaults = { doScrollingRightAway: false, animateScroll: { betweenPages: true, samePageWithHash: true, samePage: true }, scrollFriction: 0.3, scrollAcceleration: 0.04, getAnchorElement: null, offset: 0, scrollContainers: "[data-swup-scroll-container]", shouldResetScrollPosition: (o2) => true }, this.getAnchorElement = (o2 = "") => "function" == typeof this.options.getAnchorElement ? this.options.getAnchorElement(o2) : this.swup.getAnchorElement(o2), this.getOffset = (o2 = null) => "function" == typeof this.options.offset ? parseInt(this.options.offset(o2), 10) : parseInt(this.options.offset, 10), this.handleScrollToTop = () => (this.swup.scrollTo(0, this.shouldAnimate("samePage")), true), this.handleScrollToAnchor = (o2, { hash: t2 }) => this.maybeScrollToAnchor(t2, this.shouldAnimate("samePageWithHash")), this.onVisitStart = (o2) => {
      this.options.doScrollingRightAway && !o2.scroll.target && (o2.scroll.scrolledToContent = true, this.doScrollingBetweenPages(o2));
    }, this.onScrollToContent = (o2) => {
      o2.scroll.scrolledToContent || this.doScrollingBetweenPages(o2), this.restoreScrollContainers(o2);
    }, this.doScrollingBetweenPages = (o2) => {
      var t2;
      if (o2.history.popstate && !o2.animation.animate)
        return;
      if (this.maybeScrollToAnchor(o2.scroll.target, this.shouldAnimate("betweenPages")))
        return;
      if (!o2.scroll.reset)
        return;
      const s = (null == (t2 = (this.getStoredScrollPositions(this.getCurrentCacheKey()) || {}).window) ? void 0 : t2.top) || 0;
      requestAnimationFrame(() => this.swup.scrollTo(s, this.shouldAnimate("betweenPages")));
    }, this.onBeforeReplaceContent = () => {
      this.storeScrollPositions(this.currentCacheKey), this.currentCacheKey = this.getCurrentCacheKey();
    }, this.options = l({}, this.defaults, o);
  }
  mount() {
    const o = this.swup;
    o.hooks.create("scroll:start"), o.hooks.create("scroll:end"), this.scrl = new i({ onStart: () => o.hooks.callSync("scroll:start"), onEnd: () => o.hooks.callSync("scroll:end"), onCancel: () => o.hooks.callSync("scroll:end"), friction: this.options.scrollFriction, acceleration: this.options.scrollAcceleration }), o.scrollTo = (t2, s = true) => {
      s ? this.scrl.scrollTo(t2) : (o.hooks.callSync("scroll:start"), window.scrollTo(0, t2), o.hooks.callSync("scroll:end"));
    }, this.scrollPositionsStore = {}, this.currentCacheKey = this.getCurrentCacheKey(), this.previousScrollRestoration = window.history.scrollRestoration, o.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.on("visit:start", this.maybeResetScrollPositions), this.on("visit:start", this.onVisitStart), this.before("content:replace", this.onBeforeReplaceContent), this.replace("content:scroll", this.onScrollToContent), this.replace("scroll:top", this.handleScrollToTop), this.replace("scroll:anchor", this.handleScrollToAnchor);
  }
  unmount() {
    super.unmount(), window.history.scrollRestoration = this.previousScrollRestoration, delete this.swup.scrollTo, delete this.scrl;
  }
  shouldAnimate(o) {
    return "boolean" == typeof this.options.animateScroll ? this.options.animateScroll : this.options.animateScroll[o];
  }
  maybeScrollToAnchor(o, t2 = false) {
    if (!o)
      return false;
    const s = this.getAnchorElement(o);
    if (!s)
      return console.warn(`Anchor target ${o} not found`), false;
    if (!(s instanceof Element))
      return console.warn(`Anchor target ${o} is not a DOM node`), false;
    const { top: e2 } = s.getBoundingClientRect(), l2 = e2 + window.scrollY - this.getOffset(s);
    return this.swup.scrollTo(l2, t2), true;
  }
  maybeResetScrollPositions(o) {
    const { url: t2 } = o.to, { el: s } = o.trigger;
    (!s || this.options.shouldResetScrollPosition(s)) && this.resetScrollPositions(t2);
  }
  storeScrollPositions(o) {
    const s = p(this.options.scrollContainers).map((o2) => ({ top: o2.scrollTop, left: o2.scrollLeft }));
    this.scrollPositionsStore[o] = { window: { top: window.scrollY, left: window.scrollX }, containers: s };
  }
  resetScrollPositions(o) {
    const t2 = this.swup.resolveUrl(o);
    delete this.scrollPositionsStore[t2], this.scrollPositionsStore[t2] = null;
  }
  getStoredScrollPositions(o) {
    const t2 = this.swup.resolveUrl(o);
    return this.scrollPositionsStore[t2];
  }
  restoreScrollContainers() {
    const o = this.getStoredScrollPositions(this.getCurrentCacheKey()) || {};
    null != o.containers && p(this.options.scrollContainers).forEach((t2, s) => {
      const e2 = o.containers[s];
      null != e2 && (t2.scrollTop = e2.top, t2.scrollLeft = e2.left);
    });
  }
  getCurrentCacheKey() {
    return this.swup.resolveUrl(n());
  }
};

export {
  r
};
//# sourceMappingURL=chunk-P23NJCQZ.js.map
