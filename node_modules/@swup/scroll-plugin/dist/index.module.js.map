{"version":3,"file":"index.module.js","sources":["../src/index.js"],"sourcesContent":["import Plugin from '@swup/plugin';\nimport { getCurrentUrl, queryAll } from 'swup';\nimport Scrl from 'scrl';\n\n/**\n * Scroll Plugin\n * @extends Plugin\n */\nexport default class SwupScrollPlugin extends Plugin {\n\tname = 'SwupScrollPlugin';\n\n\trequires = { swup: '>=4' };\n\n\tdefaults = {\n\t\tdoScrollingRightAway: false,\n\t\tanimateScroll: {\n\t\t\tbetweenPages: true,\n\t\t\tsamePageWithHash: true,\n\t\t\tsamePage: true\n\t\t},\n\t\tscrollFriction: 0.3,\n\t\tscrollAcceleration: 0.04,\n\t\tgetAnchorElement: null,\n\t\toffset: 0,\n\t\tscrollContainers: `[data-swup-scroll-container]`,\n\t\tshouldResetScrollPosition: (link) => true\n\t};\n\n\tconstructor(options = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\tmount() {\n\t\tconst swup = this.swup;\n\n\t\tswup.hooks.create('scroll:start');\n\t\tswup.hooks.create('scroll:end');\n\n\t\t// Initialize Scrl lib for smooth animations\n\t\tthis.scrl = new Scrl({\n\t\t\tonStart: () => swup.hooks.callSync('scroll:start'),\n\t\t\tonEnd: () => swup.hooks.callSync('scroll:end'),\n\t\t\tonCancel: () => swup.hooks.callSync('scroll:end'),\n\t\t\tfriction: this.options.scrollFriction,\n\t\t\tacceleration: this.options.scrollAcceleration\n\t\t});\n\n\t\t// Add scrollTo method to swup and animate based on current animateScroll option\n\t\tswup.scrollTo = (offset, animate = true) => {\n\t\t\tif (animate) {\n\t\t\t\tthis.scrl.scrollTo(offset);\n\t\t\t} else {\n\t\t\t\tswup.hooks.callSync('scroll:start');\n\t\t\t\twindow.scrollTo(0, offset);\n\t\t\t\tswup.hooks.callSync('scroll:end');\n\t\t\t}\n\t\t};\n\n\t\t// This object will hold all scroll positions\n\t\tthis.scrollPositionsStore = {};\n\t\t// this URL helps with storing the current scroll positions on `willReplaceContent`\n\t\tthis.currentCacheKey = this.getCurrentCacheKey();\n\n\t\t// disable browser scroll control on popstates when\n\t\t// animateHistoryBrowsing option is enabled in swup.\n\t\t// Cache the previous setting to be able to properly restore it on unmount\n\t\tthis.previousScrollRestoration = window.history.scrollRestoration;\n\t\tif (swup.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t// reset scroll positions when a visit starts\n\t\tthis.on('visit:start', this.maybeResetScrollPositions);\n\n\t\t// scroll to the top of the page when a visit starts, before replacing the content\n\t\tthis.on('visit:start', this.onVisitStart);\n\n\t\t// store the current scroll positions before replacing the content\n\t\tthis.before('content:replace', this.onBeforeReplaceContent);\n\n\t\t// scroll to the top or target element after replacing the content\n\t\tthis.replace('content:scroll', this.onScrollToContent);\n\n\t\t// scroll to the top of the page\n\t\tthis.replace('scroll:top', this.handleScrollToTop);\n\n\t\t// scroll to an anchor on the same page\n\t\tthis.replace('scroll:anchor', this.handleScrollToAnchor);\n\t}\n\n\t/**\n\t * Runs when the plugin is unmounted\n\t */\n\tunmount() {\n\t\tsuper.unmount();\n\n\t\twindow.history.scrollRestoration = this.previousScrollRestoration;\n\t\tdelete this.swup.scrollTo;\n\t\tdelete this.scrl;\n\t}\n\n\t/**\n\t * Detects if a scroll should be animated, based on context\n\t * @param {string} context\n\t * @returns {boolean}\n\t */\n\tshouldAnimate(context) {\n\t\tif (typeof this.options.animateScroll === 'boolean') {\n\t\t\treturn this.options.animateScroll;\n\t\t}\n\t\treturn this.options.animateScroll[context];\n\t}\n\n\t/**\n\t * Get an element based on anchor\n\t * @param {string} hash\n\t * @returns {mixed}\n\t */\n\tgetAnchorElement = (hash = '') => {\n\t\t// Look for a custom function provided via the plugin options\n\t\tif (typeof this.options.getAnchorElement === 'function') {\n\t\t\treturn this.options.getAnchorElement(hash);\n\t\t} else {\n\t\t\treturn this.swup.getAnchorElement(hash);\n\t\t}\n\t};\n\n\t/**\n\t * Get the offset for a scroll\n\t * @param {(HtmlELement|null)} element\n\t * @returns {number}\n\t */\n\tgetOffset = (element = null) => {\n\t\t// If options.offset is a function, apply and return it\n\t\tif (typeof this.options.offset === 'function') {\n\t\t\treturn parseInt(this.options.offset(element), 10);\n\t\t}\n\t\t// Otherwise, return the sanitized offset\n\t\treturn parseInt(this.options.offset, 10);\n\t};\n\n\t/**\n\t * Scroll to top on `scroll:top` hook\n\t */\n\thandleScrollToTop = () => {\n\t\tthis.swup.scrollTo(0, this.shouldAnimate('samePage'));\n\t\treturn true;\n\t};\n\n\t/**\n\t * Scroll to anchor on `scroll:anchor` hook\n\t */\n\thandleScrollToAnchor = (visit, { hash }) => {\n\t\treturn this.maybeScrollToAnchor(hash, this.shouldAnimate('samePageWithHash'));\n\t};\n\n\t/**\n\t * Attempts to scroll to an anchor\n\t * @param {string} hash\n\t * @param {boolean} animate\n\t * @returns {boolean}\n\t */\n\tmaybeScrollToAnchor(hash, animate = false) {\n\t\tif (!hash) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst element = this.getAnchorElement(hash);\n\t\tif (!element) {\n\t\t\tconsole.warn(`Anchor target ${hash} not found`);\n\t\t\treturn false;\n\t\t}\n\t\tif (!(element instanceof Element)) {\n\t\t\tconsole.warn(`Anchor target ${hash} is not a DOM node`);\n\t\t\treturn false;\n\t\t}\n\n\t\tconst { top: elementTop } = element.getBoundingClientRect();\n\t\tconst top = elementTop + window.scrollY - this.getOffset(element);\n\t\tthis.swup.scrollTo(top, animate);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Check whether to scroll in `visit:start` hook\n\t */\n\tonVisitStart = (visit) => {\n\t\tif (this.options.doScrollingRightAway && !visit.scroll.target) {\n\t\t\tvisit.scroll.scrolledToContent = true;\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t};\n\n\t/**\n\t * Check whether to scroll in `content:scroll` hook\n\t */\n\tonScrollToContent = (visit) => {\n\t\tif (!visit.scroll.scrolledToContent) {\n\t\t\tthis.doScrollingBetweenPages(visit);\n\t\t}\n\t\tthis.restoreScrollContainers(visit);\n\t};\n\n\t/**\n\t * Scrolls the window\n\t * @returns {void}\n\t */\n\tdoScrollingBetweenPages = (visit) => {\n\t\t// Bail early on popstate if not animated: browser will handle it\n\t\tif (visit.history.popstate && !visit.animation.animate) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Try scrolling to a given anchor\n\t\tif (this.maybeScrollToAnchor(visit.scroll.target, this.shouldAnimate('betweenPages'))) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Allow not resetting scroll position\n\t\tif (!visit.scroll.reset) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Finally, scroll to either the stored scroll position or to the very top of the page\n\t\tconst scrollPositions = this.getStoredScrollPositions(this.getCurrentCacheKey()) || {};\n\t\tconst top = scrollPositions.window?.top || 0;\n\n\t\t// Give possible JavaScript time to execute before scrolling\n\t\trequestAnimationFrame(() => this.swup.scrollTo(top, this.shouldAnimate('betweenPages')));\n\t};\n\n\t/**\n\t * Stores the current scroll positions for the URL we just came from\n\t */\n\tonBeforeReplaceContent = () => {\n\t\tthis.storeScrollPositions(this.currentCacheKey);\n\t\tthis.currentCacheKey = this.getCurrentCacheKey();\n\t};\n\n\t/**\n\t * Deletes the scroll positions for the URL a link is pointing to,\n\t * if shouldResetScrollPosition evaluates to true\n\t * @returns {void}\n\t */\n\tmaybeResetScrollPositions(visit) {\n\t\tconst { url } = visit.to;\n\t\tconst { el } = visit.trigger;\n\t\tconst shouldReset = !el || this.options.shouldResetScrollPosition(el);\n\t\tif (shouldReset) {\n\t\t\tthis.resetScrollPositions(url);\n\t\t}\n\t}\n\n\t/**\n\t * Stores the scroll positions for the current URL\n\t * @param {string} url\n\t * @returns {void}\n\t */\n\tstoreScrollPositions(url) {\n\t\t// retrieve the current scroll position for all containers\n\t\tconst containers = queryAll(this.options.scrollContainers).map((el) => ({\n\t\t\ttop: el.scrollTop,\n\t\t\tleft: el.scrollLeft\n\t\t}));\n\n\t\t// construct the final object entry, with the window scroll positions added\n\t\tthis.scrollPositionsStore[url] = {\n\t\t\twindow: { top: window.scrollY, left: window.scrollX },\n\t\t\tcontainers\n\t\t};\n\t}\n\n\t/**\n\t * Resets stored scroll positions for a given URL\n\t * @param {string} url\n\t */\n\tresetScrollPositions(url) {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\tdelete this.scrollPositionsStore[cacheKey];\n\t\tthis.scrollPositionsStore[cacheKey] = null;\n\t}\n\n\t/**\n\t * Get the stored scroll positions for a given URL from the cache\n\t * @returns {(object|undefined)}\n\t */\n\tgetStoredScrollPositions(url) {\n\t\tconst cacheKey = this.swup.resolveUrl(url);\n\t\treturn this.scrollPositionsStore[cacheKey];\n\t}\n\n\t/**\n\t * Restore the scroll positions for all matching scrollContainers\n\t * @returns void\n\t */\n\trestoreScrollContainers() {\n\t\t// get the stored scroll positions from the cache\n\t\tconst scrollPositions = this.getStoredScrollPositions(this.getCurrentCacheKey()) || {};\n\t\tif (scrollPositions.containers == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// cycle through all containers on the current page and restore their scroll positions, if appropriate\n\t\tqueryAll(this.options.scrollContainers).forEach((el, index) => {\n\t\t\tconst scrollPosition = scrollPositions.containers[index];\n\t\t\tif (scrollPosition == null) return;\n\t\t\tel.scrollTop = scrollPosition.top;\n\t\t\tel.scrollLeft = scrollPosition.left;\n\t\t});\n\t}\n\n\t/**\n\t * Get the current cache key for the scroll positions.\n\t * @returns {string}\n\t */\n\tgetCurrentCacheKey() {\n\t\treturn this.swup.resolveUrl(getCurrentUrl());\n\t}\n}\n"],"names":["SwupScrollPlugin","Plugin","constructor","options","_this","super","name","requires","swup","this","defaults","doScrollingRightAway","animateScroll","betweenPages","samePageWithHash","samePage","scrollFriction","scrollAcceleration","getAnchorElement","offset","scrollContainers","shouldResetScrollPosition","link","hash","getOffset","element","parseInt","handleScrollToTop","scrollTo","shouldAnimate","handleScrollToAnchor","visit","_ref","maybeScrollToAnchor","onVisitStart","scroll","target","scrolledToContent","doScrollingBetweenPages","onScrollToContent","restoreScrollContainers","history","popstate","animation","animate","reset","top","getStoredScrollPositions","getCurrentCacheKey","window","requestAnimationFrame","onBeforeReplaceContent","storeScrollPositions","currentCacheKey","mount","_this2","hooks","create","scrl","Scrl","onStart","callSync","onEnd","onCancel","friction","acceleration","scrollPositionsStore","previousScrollRestoration","scrollRestoration","animateHistoryBrowsing","on","maybeResetScrollPositions","before","replace","unmount","context","console","warn","Element","elementTop","getBoundingClientRect","scrollY","url","to","el","trigger","resetScrollPositions","containers","queryAll","map","scrollTop","left","scrollLeft","scrollX","resolveUrl","cacheKey","scrollPositions","forEach","index","scrollPosition","getCurrentUrl"],"mappings":"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"}