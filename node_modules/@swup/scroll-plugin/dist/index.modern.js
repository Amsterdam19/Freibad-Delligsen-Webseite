import o from"@swup/plugin";import{queryAll as t,getCurrentUrl as s}from"swup";import e from"scrl";function l(){return l=Object.assign?Object.assign.bind():function(o){for(var t=1;t<arguments.length;t++){var s=arguments[t];for(var e in s)Object.prototype.hasOwnProperty.call(s,e)&&(o[e]=s[e])}return o},l.apply(this,arguments)}class r extends o{constructor(o={}){super(),this.name="SwupScrollPlugin",this.requires={swup:">=4"},this.defaults={doScrollingRightAway:!1,animateScroll:{betweenPages:!0,samePageWithHash:!0,samePage:!0},scrollFriction:.3,scrollAcceleration:.04,getAnchorElement:null,offset:0,scrollContainers:"[data-swup-scroll-container]",shouldResetScrollPosition:o=>!0},this.getAnchorElement=(o="")=>"function"==typeof this.options.getAnchorElement?this.options.getAnchorElement(o):this.swup.getAnchorElement(o),this.getOffset=(o=null)=>"function"==typeof this.options.offset?parseInt(this.options.offset(o),10):parseInt(this.options.offset,10),this.handleScrollToTop=()=>(this.swup.scrollTo(0,this.shouldAnimate("samePage")),!0),this.handleScrollToAnchor=(o,{hash:t})=>this.maybeScrollToAnchor(t,this.shouldAnimate("samePageWithHash")),this.onVisitStart=o=>{this.options.doScrollingRightAway&&!o.scroll.target&&(o.scroll.scrolledToContent=!0,this.doScrollingBetweenPages(o))},this.onScrollToContent=o=>{o.scroll.scrolledToContent||this.doScrollingBetweenPages(o),this.restoreScrollContainers(o)},this.doScrollingBetweenPages=o=>{var t;if(o.history.popstate&&!o.animation.animate)return;if(this.maybeScrollToAnchor(o.scroll.target,this.shouldAnimate("betweenPages")))return;if(!o.scroll.reset)return;const s=(null==(t=(this.getStoredScrollPositions(this.getCurrentCacheKey())||{}).window)?void 0:t.top)||0;requestAnimationFrame(()=>this.swup.scrollTo(s,this.shouldAnimate("betweenPages")))},this.onBeforeReplaceContent=()=>{this.storeScrollPositions(this.currentCacheKey),this.currentCacheKey=this.getCurrentCacheKey()},this.options=l({},this.defaults,o)}mount(){const o=this.swup;o.hooks.create("scroll:start"),o.hooks.create("scroll:end"),this.scrl=new e({onStart:()=>o.hooks.callSync("scroll:start"),onEnd:()=>o.hooks.callSync("scroll:end"),onCancel:()=>o.hooks.callSync("scroll:end"),friction:this.options.scrollFriction,acceleration:this.options.scrollAcceleration}),o.scrollTo=(t,s=!0)=>{s?this.scrl.scrollTo(t):(o.hooks.callSync("scroll:start"),window.scrollTo(0,t),o.hooks.callSync("scroll:end"))},this.scrollPositionsStore={},this.currentCacheKey=this.getCurrentCacheKey(),this.previousScrollRestoration=window.history.scrollRestoration,o.options.animateHistoryBrowsing&&(window.history.scrollRestoration="manual"),this.on("visit:start",this.maybeResetScrollPositions),this.on("visit:start",this.onVisitStart),this.before("content:replace",this.onBeforeReplaceContent),this.replace("content:scroll",this.onScrollToContent),this.replace("scroll:top",this.handleScrollToTop),this.replace("scroll:anchor",this.handleScrollToAnchor)}unmount(){super.unmount(),window.history.scrollRestoration=this.previousScrollRestoration,delete this.swup.scrollTo,delete this.scrl}shouldAnimate(o){return"boolean"==typeof this.options.animateScroll?this.options.animateScroll:this.options.animateScroll[o]}maybeScrollToAnchor(o,t=!1){if(!o)return!1;const s=this.getAnchorElement(o);if(!s)return console.warn(`Anchor target ${o} not found`),!1;if(!(s instanceof Element))return console.warn(`Anchor target ${o} is not a DOM node`),!1;const{top:e}=s.getBoundingClientRect(),l=e+window.scrollY-this.getOffset(s);return this.swup.scrollTo(l,t),!0}maybeResetScrollPositions(o){const{url:t}=o.to,{el:s}=o.trigger;(!s||this.options.shouldResetScrollPosition(s))&&this.resetScrollPositions(t)}storeScrollPositions(o){const s=t(this.options.scrollContainers).map(o=>({top:o.scrollTop,left:o.scrollLeft}));this.scrollPositionsStore[o]={window:{top:window.scrollY,left:window.scrollX},containers:s}}resetScrollPositions(o){const t=this.swup.resolveUrl(o);delete this.scrollPositionsStore[t],this.scrollPositionsStore[t]=null}getStoredScrollPositions(o){const t=this.swup.resolveUrl(o);return this.scrollPositionsStore[t]}restoreScrollContainers(){const o=this.getStoredScrollPositions(this.getCurrentCacheKey())||{};null!=o.containers&&t(this.options.scrollContainers).forEach((t,s)=>{const e=o.containers[s];null!=e&&(t.scrollTop=e.top,t.scrollLeft=e.left)})}getCurrentCacheKey(){return this.swup.resolveUrl(s())}}export{r as default};
//# sourceMappingURL=index.modern.js.map
