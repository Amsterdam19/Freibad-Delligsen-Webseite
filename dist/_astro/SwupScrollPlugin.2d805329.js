import{e as h}from"./index.modern.d96712a8.js";import{p as l,n as a}from"./Swup.33d05aac.js";function n(){return n=Object.assign?Object.assign.bind():function(i){for(var o=1;o<arguments.length;o++){var t=arguments[o];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(i[s]=t[s])}return i},n.apply(this,arguments)}class u{constructor(o){this._raf=null,this._positionY=0,this._velocityY=0,this._targetPositionY=0,this._targetPositionYWithOffset=0,this._direction=0,this.scrollTo=t=>{if(t&&t.nodeType)this._targetPositionY=Math.round(t.getBoundingClientRect().top+window.pageYOffset);else{if(parseInt(this._targetPositionY)!==this._targetPositionY)return void console.error("Argument must be a number or an element.");this._targetPositionY=Math.round(t)}this._targetPositionY>document.documentElement.scrollHeight-window.innerHeight&&(this._targetPositionY=document.documentElement.scrollHeight-window.innerHeight),this._positionY=document.body.scrollTop||document.documentElement.scrollTop,this._direction=this._positionY>this._targetPositionY?-1:1,this._targetPositionYWithOffset=this._targetPositionY+this._direction,this._velocityY=0,this._positionY!==this._targetPositionY?(this.options.onStart(),this._animate()):this.options.onAlreadyAtPositions()},this._animate=()=>{this._update(),this._render(),this._direction===1&&this._targetPositionY>this._positionY||this._direction===-1&&this._targetPositionY<this._positionY?(this._raf=requestAnimationFrame(this._animate),this.options.onTick()):(this._positionY=this._targetPositionY,this._render(),this._raf=null,this.options.onTick(),this.options.onEnd())},this._update=()=>{const t=this._targetPositionYWithOffset-this._positionY;return this._velocityY+=t*this.options.acceleration,this._velocityY*=this.options.friction,this._positionY+=this._velocityY,Math.abs(t)},this._render=()=>{window.scrollTo(0,this._positionY)},this.options=n({},{onAlreadyAtPositions:()=>{},onCancel:()=>{},onEnd:()=>{},onStart:()=>{},onTick:()=>{},friction:.7,acceleration:.04},o),o&&o.friction&&(this.options.friction=1-o.friction),window.addEventListener("mousewheel",t=>{this._raf&&(this.options.onCancel(),cancelAnimationFrame(this._raf),this._raf=null)},{passive:!0})}}function r(){return r=Object.assign?Object.assign.bind():function(i){for(var o=1;o<arguments.length;o++){var t=arguments[o];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(i[s]=t[s])}return i},r.apply(this,arguments)}class g extends h{constructor(o={}){super(),this.name="SwupScrollPlugin",this.requires={swup:">=4"},this.defaults={doScrollingRightAway:!1,animateScroll:{betweenPages:!0,samePageWithHash:!0,samePage:!0},scrollFriction:.3,scrollAcceleration:.04,getAnchorElement:null,offset:0,scrollContainers:"[data-swup-scroll-container]",shouldResetScrollPosition:t=>!0},this.getAnchorElement=(t="")=>typeof this.options.getAnchorElement=="function"?this.options.getAnchorElement(t):this.swup.getAnchorElement(t),this.getOffset=(t=null)=>typeof this.options.offset=="function"?parseInt(this.options.offset(t),10):parseInt(this.options.offset,10),this.handleScrollToTop=()=>(this.swup.scrollTo(0,this.shouldAnimate("samePage")),!0),this.handleScrollToAnchor=(t,{hash:s})=>this.maybeScrollToAnchor(s,this.shouldAnimate("samePageWithHash")),this.onVisitStart=t=>{this.options.doScrollingRightAway&&!t.scroll.target&&(t.scroll.scrolledToContent=!0,this.doScrollingBetweenPages(t))},this.onScrollToContent=t=>{t.scroll.scrolledToContent||this.doScrollingBetweenPages(t),this.restoreScrollContainers(t)},this.doScrollingBetweenPages=t=>{var s;if(t.history.popstate&&!t.animation.animate||this.maybeScrollToAnchor(t.scroll.target,this.shouldAnimate("betweenPages"))||!t.scroll.reset)return;const e=((s=(this.getStoredScrollPositions(this.getCurrentCacheKey())||{}).window)==null?void 0:s.top)||0;requestAnimationFrame(()=>this.swup.scrollTo(e,this.shouldAnimate("betweenPages")))},this.onBeforeReplaceContent=()=>{this.storeScrollPositions(this.currentCacheKey),this.currentCacheKey=this.getCurrentCacheKey()},this.options=r({},this.defaults,o)}mount(){const o=this.swup;o.hooks.create("scroll:start"),o.hooks.create("scroll:end"),this.scrl=new u({onStart:()=>o.hooks.callSync("scroll:start"),onEnd:()=>o.hooks.callSync("scroll:end"),onCancel:()=>o.hooks.callSync("scroll:end"),friction:this.options.scrollFriction,acceleration:this.options.scrollAcceleration}),o.scrollTo=(t,s=!0)=>{s?this.scrl.scrollTo(t):(o.hooks.callSync("scroll:start"),window.scrollTo(0,t),o.hooks.callSync("scroll:end"))},this.scrollPositionsStore={},this.currentCacheKey=this.getCurrentCacheKey(),this.previousScrollRestoration=window.history.scrollRestoration,o.options.animateHistoryBrowsing&&(window.history.scrollRestoration="manual"),this.on("visit:start",this.maybeResetScrollPositions),this.on("visit:start",this.onVisitStart),this.before("content:replace",this.onBeforeReplaceContent),this.replace("content:scroll",this.onScrollToContent),this.replace("scroll:top",this.handleScrollToTop),this.replace("scroll:anchor",this.handleScrollToAnchor)}unmount(){super.unmount(),window.history.scrollRestoration=this.previousScrollRestoration,delete this.swup.scrollTo,delete this.scrl}shouldAnimate(o){return typeof this.options.animateScroll=="boolean"?this.options.animateScroll:this.options.animateScroll[o]}maybeScrollToAnchor(o,t=!1){if(!o)return!1;const s=this.getAnchorElement(o);if(!s)return console.warn(`Anchor target ${o} not found`),!1;if(!(s instanceof Element))return console.warn(`Anchor target ${o} is not a DOM node`),!1;const{top:e}=s.getBoundingClientRect(),c=e+window.scrollY-this.getOffset(s);return this.swup.scrollTo(c,t),!0}maybeResetScrollPositions(o){const{url:t}=o.to,{el:s}=o.trigger;(!s||this.options.shouldResetScrollPosition(s))&&this.resetScrollPositions(t)}storeScrollPositions(o){const t=l(this.options.scrollContainers).map(s=>({top:s.scrollTop,left:s.scrollLeft}));this.scrollPositionsStore[o]={window:{top:window.scrollY,left:window.scrollX},containers:t}}resetScrollPositions(o){const t=this.swup.resolveUrl(o);delete this.scrollPositionsStore[t],this.scrollPositionsStore[t]=null}getStoredScrollPositions(o){const t=this.swup.resolveUrl(o);return this.scrollPositionsStore[t]}restoreScrollContainers(){const o=this.getStoredScrollPositions(this.getCurrentCacheKey())||{};o.containers!=null&&l(this.options.scrollContainers).forEach((t,s)=>{const e=o.containers[s];e!=null&&(t.scrollTop=e.top,t.scrollLeft=e.left)})}getCurrentCacheKey(){return this.swup.resolveUrl(a())}}export{g as default};
